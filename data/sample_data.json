{
  "easy_problems": [
    {
      "id": "easy_001",
      "problem": "Write a function that takes two numbers as input and returns their sum.",
      "solution": "def add_numbers(a, b):\n    \"\"\"Add two numbers and return the result.\"\"\"\n    return a + b",
      "difficulty": "easy",
      "tags": ["arithmetic", "basic"],
      "test_cases": [
        {"input": "2, 3", "output": "5"},
        {"input": "-1, 1", "output": "0"},
        {"input": "0, 0", "output": "0"},
        {"input": "100, 200", "output": "300"}
      ],
      "complexity": 1
    },
    {
      "id": "easy_002", 
      "problem": "Write a function to check if a number is even or odd. Return 'even' if the number is even, 'odd' if it's odd.",
      "solution": "def check_even_odd(n):\n    \"\"\"Check if a number is even or odd.\"\"\"\n    if n % 2 == 0:\n        return 'even'\n    else:\n        return 'odd'",
      "difficulty": "easy",
      "tags": ["conditional", "modulo"],
      "test_cases": [
        {"input": "4", "output": "even"},
        {"input": "7", "output": "odd"},
        {"input": "0", "output": "even"},
        {"input": "-3", "output": "odd"}
      ],
      "complexity": 2
    },
    {
      "id": "easy_003",
      "problem": "Write a function that reverses a string.",
      "solution": "def reverse_string(s):\n    \"\"\"Reverse a given string.\"\"\"\n    return s[::-1]",
      "difficulty": "easy",
      "tags": ["string", "slicing"],
      "test_cases": [
        {"input": "'hello'", "output": "olleh"},
        {"input": "'python'", "output": "nohtyp"},
        {"input": "'a'", "output": "a"},
        {"input": "''", "output": ""}
      ],
      "complexity": 1
    }
  ],
  "medium_problems": [
    {
      "id": "medium_001",
      "problem": "Write a function that finds all prime numbers up to a given number n using the Sieve of Eratosthenes algorithm.",
      "solution": "def sieve_of_eratosthenes(n):\n    \"\"\"Find all prime numbers up to n using Sieve of Eratosthenes.\"\"\"\n    if n < 2:\n        return []\n    \n    # Initialize sieve\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    \n    # Sieve process\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    \n    # Collect primes\n    primes = [i for i in range(2, n + 1) if is_prime[i]]\n    return primes",
      "difficulty": "medium",
      "tags": ["algorithm", "prime", "optimization"],
      "test_cases": [
        {"input": "10", "output": "[2, 3, 5, 7]"},
        {"input": "20", "output": "[2, 3, 5, 7, 11, 13, 17, 19]"},
        {"input": "1", "output": "[]"},
        {"input": "30", "output": "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]"}
      ],
      "complexity": 4
    },
    {
      "id": "medium_002",
      "problem": "Implement a function that performs binary search on a sorted array. Return the index of the target element, or -1 if not found.",
      "solution": "def binary_search(arr, target):\n    \"\"\"Perform binary search on a sorted array.\"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
      "difficulty": "medium",
      "tags": ["search", "algorithm", "divide-conquer"],
      "test_cases": [
        {"input": "[1, 3, 5, 7, 9], 5", "output": "2"},
        {"input": "[1, 3, 5, 7, 9], 1", "output": "0"},
        {"input": "[1, 3, 5, 7, 9], 9", "output": "4"},
        {"input": "[1, 3, 5, 7, 9], 4", "output": "-1"}
      ],
      "complexity": 3
    },
    {
      "id": "medium_003",
      "problem": "Write a function to find the longest common subsequence (LCS) of two strings using dynamic programming.",
      "solution": "def longest_common_subsequence(s1, s2):\n    \"\"\"Find the longest common subsequence of two strings.\"\"\"\n    m, n = len(s1), len(s2)\n    \n    # Create DP table\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i-1] == s2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    \n    # Reconstruct LCS\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if s1[i-1] == s2[j-1]:\n            lcs.append(s1[i-1])\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return ''.join(reversed(lcs))",
      "difficulty": "medium",
      "tags": ["dynamic-programming", "string", "optimization"],
      "test_cases": [
        {"input": "'ABCDGH', 'AEDFHR'", "output": "ADH"},
        {"input": "'AGGTAB', 'GXTXAYB'", "output": "GTAB"},
        {"input": "'ABC', 'DEF'", "output": ""},
        {"input": "'AAA', 'AAA'", "output": "AAA"}
      ],
      "complexity": 5
    }
  ],
  "hard_problems": [
    {
      "id": "hard_001",
      "problem": "Implement a function to solve the N-Queens problem. Return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration where 'Q' represents a queen and '.' represents an empty space.",
      "solution": "def solve_n_queens(n):\n    \"\"\"Solve the N-Queens problem.\"\"\"\n    def is_safe(board, row, col):\n        # Check column\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n        \n        # Check upper-left diagonal\n        i, j = row - 1, col - 1\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j -= 1\n        \n        # Check upper-right diagonal\n        i, j = row - 1, col + 1\n        while i >= 0 and j < n:\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j += 1\n        \n        return True\n    \n    def solve(board, row):\n        if row == n:\n            # Found a solution\n            solutions.append([''.join(row) for row in board])\n            return\n        \n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row][col] = 'Q'\n                solve(board, row + 1)\n                board[row][col] = '.'\n    \n    solutions = []\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    solve(board, 0)\n    return solutions",
      "difficulty": "hard",
      "tags": ["backtracking", "recursion", "constraint-satisfaction"],
      "test_cases": [
        {"input": "4", "output": "[['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]"},
        {"input": "1", "output": "[['Q']]"},
        {"input": "2", "output": "[]"},
        {"input": "3", "output": "[]"}
      ],
      "complexity": 8
    },
    {
      "id": "hard_002",
      "problem": "Implement Dijkstra's algorithm to find the shortest path from a source vertex to all other vertices in a weighted graph. The graph is represented as an adjacency list where graph[u] = [(v, weight), ...].",
      "solution": "import heapq\n\ndef dijkstra(graph, source):\n    \"\"\"Find shortest paths from source to all vertices using Dijkstra's algorithm.\"\"\"\n    n = len(graph)\n    \n    # Initialize distances\n    distances = [float('inf')] * n\n    distances[source] = 0\n    \n    # Priority queue: (distance, vertex)\n    pq = [(0, source)]\n    \n    # Track visited vertices\n    visited = set()\n    \n    while pq:\n        curr_dist, u = heapq.heappop(pq)\n        \n        # Skip if already visited\n        if u in visited:\n            continue\n        \n        visited.add(u)\n        \n        # Relax edges\n        for v, weight in graph[u]:\n            if v not in visited:\n                new_dist = curr_dist + weight\n                if new_dist < distances[v]:\n                    distances[v] = new_dist\n                    heapq.heappush(pq, (new_dist, v))\n    \n    return distances",
      "difficulty": "hard",
      "tags": ["graph", "shortest-path", "greedy", "heap"],
      "test_cases": [
        {
          "input": "{0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}, 0",
          "output": "[0, 3, 1, 4]"
        },
        {
          "input": "{0: [(1, 10), (2, 3)], 1: [(2, 1), (3, 2)], 2: [(1, 4), (3, 8)], 3: []}, 0",
          "output": "[0, 7, 3, 9]"
        }
      ],
      "complexity": 7
    },
    {
      "id": "hard_003",
      "problem": "Implement a Trie (Prefix Tree) data structure with insert, search, and startsWith methods. The Trie should efficiently store and retrieve strings.",
      "solution": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    \"\"\"Trie (Prefix Tree) implementation.\"\"\"\n    \n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        \"\"\"Insert a word into the trie.\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word):\n        \"\"\"Search for a word in the trie.\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n    \n    def startsWith(self, prefix):\n        \"\"\"Check if any word starts with the given prefix.\"\"\"\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n    \n    def get_all_words(self, prefix=''):\n        \"\"\"Get all words with the given prefix.\"\"\"\n        def dfs(node, path, words):\n            if node.is_end_of_word:\n                words.append(path)\n            for char, child in node.children.items():\n                dfs(child, path + char, words)\n        \n        # Navigate to prefix node\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return []\n            node = node.children[char]\n        \n        # Find all words from this node\n        words = []\n        dfs(node, prefix, words)\n        return words",
      "difficulty": "hard",
      "tags": ["data-structure", "tree", "string", "design"],
      "test_cases": [
        {
          "input": "operations: ['insert', 'search', 'startsWith'], args: [['apple'], ['apple'], ['app']]",
          "output": "[None, True, True]"
        },
        {
          "input": "operations: ['insert', 'insert', 'search', 'startsWith'], args: [['app'], ['apple'], ['appl'], ['app']]",
          "output": "[None, None, False, True]"
        }
      ],
      "complexity": 6
    }
  ],
  "metadata": {
    "total_problems": 9,
    "distribution": {
      "easy": 3,
      "medium": 3,
      "hard": 3
    },
    "tags": [
      "arithmetic", "basic", "conditional", "modulo", "string", "slicing",
      "algorithm", "prime", "optimization", "search", "divide-conquer",
      "dynamic-programming", "backtracking", "recursion", "constraint-satisfaction",
      "graph", "shortest-path", "greedy", "heap", "data-structure", "tree", "design"
    ],
    "average_complexity": 4.44,
    "languages": ["python"],
    "version": "1.0.0"
  }
}